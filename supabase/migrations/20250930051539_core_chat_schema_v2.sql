-- CORE CHAT SCHEMA (final ordering): rooms, memberships, messages + RLS

-- helper (idempotent)
create or replace function public.set_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

-- 1) ROOMS (no policy referencing memberships yet)
create table if not exists public.rooms (
  id uuid primary key default gen_random_uuid(),
  name text not null,
  is_private boolean not null default false,
  created_by uuid references public.profiles(id) on delete set null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

drop trigger if exists rooms_set_updated_at on public.rooms;
create trigger rooms_set_updated_at
before update on public.rooms
for each row execute function public.set_updated_at();

alter table public.rooms enable row level security;

-- Basic policies that don't depend on memberships
drop policy if exists "rooms_insert_authenticated" on public.rooms;
create policy "rooms_insert_authenticated" on public.rooms
for insert
with check (
  exists (select 1 from public.profiles p where p.id = auth.uid())
);

drop policy if exists "rooms_update_creator" on public.rooms;
create policy "rooms_update_creator" on public.rooms
for update
using (created_by = auth.uid())
with check (created_by = auth.uid());

-- 2) MEMBERSHIPS (create before any rooms policy that references it)
create table if not exists public.memberships (
  room_id uuid not null references public.rooms(id) on delete cascade,
  profile_id uuid not null references public.profiles(id) on delete cascade,
  role text not null default 'member' check (role in ('member','moderator','owner')),
  created_at timestamptz not null default now(),
  primary key (room_id, profile_id)
);

alter table public.memberships enable row level security;

drop policy if exists "memberships_select_self_room" on public.memberships;
create policy "memberships_select_self_room" on public.memberships
for select
using (
  exists (
    select 1
    from public.memberships m2
    where m2.room_id = public.memberships.room_id
      and m2.profile_id = auth.uid()
  )
);

drop policy if exists "memberships_insert_self" on public.memberships;
create policy "memberships_insert_self" on public.memberships
for insert
with check (profile_id = auth.uid());

drop policy if exists "memberships_delete_self" on public.memberships;
create policy "memberships_delete_self" on public.memberships
for delete
using (profile_id = auth.uid());

-- Now that memberships exists, add the rooms SELECT policy that references it
drop policy if exists "rooms_select_member_or_public" on public.rooms;
create policy "rooms_select_member_or_public" on public.rooms
for select
using (
  not is_private
  or exists (
    select 1
    from public.memberships m
    where m.room_id = public.rooms.id
      and m.profile_id = auth.uid()
  )
);

-- 3) MESSAGES
create table if not exists public.messages (
  id bigint generated by default as identity primary key,
  room_id uuid not null references public.rooms(id) on delete cascade,
  profile_id uuid references public.profiles(id) on delete set null,
  content text not null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  is_deleted boolean not null default false,
  flagged boolean not null default false
);

drop trigger if exists messages_set_updated_at on public.messages;
create trigger messages_set_updated_at
before update on public.messages
for each row execute function public.set_updated_at();

create index if not exists messages_room_created_idx
  on public.messages (room_id, created_at desc);

alter table public.messages enable row level security;

drop policy if exists "messages_select_member_or_public" on public.messages;
create policy "messages_select_member_or_public" on public.messages
for select
using (
  exists (
    select 1 from public.rooms r
    where r.id = public.messages.room_id
      and (
        not r.is_private
        or exists (
          select 1 from public.memberships m
          where m.room_id = r.id and m.profile_id = auth.uid()
        )
      )
  )
);

drop policy if exists "messages_insert_member" on public.messages;
create policy "messages_insert_member" on public.messages
for insert
with check (
  profile_id = auth.uid()
  and exists (
    select 1 from public.rooms r
    where r.id = public.messages.room_id
      and (
        not r.is_private
        or exists (
          select 1 from public.memberships m
          where m.room_id = r.id and m.profile_id = auth.uid()
        )
      )
  )
);

drop policy if exists "messages_update_self" on public.messages;
create policy "messages_update_self" on public.messages
for update
using (profile_id = auth.uid())
with check (profile_id = auth.uid());
